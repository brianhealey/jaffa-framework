Auto generated database keys
============================

In Jaffa 1.3 we added a new feature to support the auto-generation of keys via the database.

In Microsoft SQL Server 2000, you can define a column as "IDENTITY (1, 1)" which will cause the database
on insert to generate a unique value for this column. In MySQL you can use the "AUTO_INCREMENT" directive to 
achive the same thing.

In Jaffa 1.2, when the persistence engine did an INSERT into the database, it would try and insert
a 'null' value into this column, causing an error, in v1.3 this column, if flagged as a auto-generated
key, it will not be included in the INSERT statement.

To use this feature, there is a new optional tag in the domain object pattern called <AutoGenerated>.
The DTD and XSD have been updated to reflect this, but as this in a backwards compatible changed, these
have been added to the v1.0 of the pattern

Here is an example of it being used (from the unit tests)

        <Field>
            <Name>AssetTk</Name>
            <DataType>java.lang.Long</DataType>
            <DatabaseFieldName>ASSET_TK</DatabaseFieldName>
            <DatabaseDataType>Integer</DatabaseDataType>
            <PrimaryKey>T</PrimaryKey>
            <AutoGenerated>true</AutoGenerated>
            <Description></Description>
            <LabelToken>[label.App1.Material.Asset.AssetTk]</LabelToken>
            <Mandatory>F</Mandatory>
            <IntSize>20</IntSize>
        </Field>

Column definition in MySQL
	ASSET_TK BIGINT NOT NULL AUTO_INCREMENT

Column definition in Microsoft SQL Server 2000
        "ASSET_TK" NUMERIC(20) IDENTITY (1, 1) NOT NULL


Note, that although this is a key field, which we would normally mark as mandatory, in this case
we don't as we leave this field 'null' when we create the domain object, its up to the database 
to populate it. If we leave it mandatory, we will get a 'MandatoryFieldException' when we do a 
uow.add(..) on this object.

In the database mapping files, there is a new attribute to indicate an auto generated field
	
	<classmap>
	    <class name="org.jaffa.persistence.domainobjects.Asset">
		<map-to table="ZZ_JUT_ASSET" />

		<field name="AssetTk" type="java.lang.Long" primary-key="true" autogen-key="true">
		    <sql name="ASSET_TK" type="Integer" dirty="ignore"/>
		</field>

		....

	    </class>
	</classmap>


If after you have committed your new domain object, you want to find out what the value of the key
is you must re-read the record. The challange here is if this is the unique key, you must re-read 
the record using a 'unique function key' that you know from when the record was added.

Jaffa does not make use of the 'getGeneratedKey()' facility new in JDBC3.0 which allows auto-genrated
keys to be read back in, as we only require JDBC 2.0 complient drivers.

If you have a situation where to you have a master-child relationship, and what to create a master, and child
record in a single transaction, and have the master use a generated key, and then propergate that key to the
child, then we recommend writing a 'key generation' routine in Java (org.jaffa.util.Voucher is a primative
example), and not using database generated keys.


Oracle
======

For oracle users, you really don't have this direct feature, but you can create a database sequence, and then
use a (pre insert) trigger, to populate the key field from the sequence. In this case you don't want to flag
the field as 'AutoGenerated', but if the database is populating the value, you'll still need to set 'Mandatory' 
equal to false ('F')

To achieve the same result as in the above example, add the followinf to the database...

	CREATE SEQUENCE asset_tk_sequence START WITH 1;

	CREATE OR REPLACE TRIGGER zz_jut_asset_asset_tk
	BEFORE INSERT ON zz_jut_asset
	FOR EACH ROW
	BEGIN
	  select asset_tk_sequence.NEXTVAL into :new.asset_tk from dual;
	END;



